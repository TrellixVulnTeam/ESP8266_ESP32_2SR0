#!/bin/sh

KERNELVERSION=`uname -r`
PATH=/sbin:/bin:/usr/sbin:/usr/bin
export PATH

umask 022

/etc/init.d/rcS.mountfs

#
# Force a system to reboot upon getting any kind of 'oops'
#
echo 1 > /proc/sys/kernel/panic_on_oops

# Initialize random number generator
[ -f /lib/modules/randseed.ko ] && insmod /lib/modules/randseed.ko
[ -f /etc/init.d/initrandom ] && /etc/init.d/initrandom start

## enable mdev if any
if [ -f /sbin/mdev ] && [ -f /etc/mdev.conf ]; then
  echo > /dev/mdev.seq
  echo /sbin/mdev > /proc/sys/kernel/hotplug
  mdev -s
fi

mkdir -p /var/dev
mkdir -p /var/run
mkdir -p /var/tmp
chmod 1777 /var/dev
chmod 1777 /var/run
chmod 1777 /var/tmp
mkdir -p /var/usbmgr/class
mkdir -p /var/usbmgr/vendor

# make sure encrypted filesystems are mounted before we proceed
[ -f /etc/init.d/cryptomount ] && [ -f /usr/sbin/fssetup ] && /etc/init.d/cryptomount start

# Load ralink wl driver (must be done as soon as possible because of the big memory allocations it does)
[ -f /lib/modules/${KERNELVERSION}/kernel/drivers/usb/host/dwc_otg_host1.ko ] && insmod /lib/modules/${KERNELVERSION}/kernel/drivers/usb/host/dwc_otg_host1.ko
[ -f /lib/modules/${KERNELVERSION}/kernel/drivers/net/wireless/ralink/rt3070ap.ko ] && insmod /lib/modules/${KERNELVERSION}/kernel/drivers/net/wireless/ralink/rt3070ap.ko

# load kernel serial port module
[ -f /lib/modules/kserport.ko ] && insmod /lib/modules/kserport.ko

# load kernel RTC module
[ -f /lib/modules/`uname -r`/extra/rtc.ko ] && insmod /lib/modules/`uname -r`/extra/rtc.ko

# Load cryptodev module
/bin/echo "loading cryptodev kernel modules..."
[ -f /middleware/usr/bin/cryptodev.ko ] && insmod /middleware/usr/bin/cryptodev.ko

# Load crypto_wrapper module
/bin/echo "loading crypto_wrapper kernel modules..."
[ -f /lib/modules/crypto_wrapper.ko ] && insmod /lib/modules/crypto_wrapper.ko

[ -f /nmon/nmon.ko ] && insmod /nmon/nmon.ko

/bin/echo "loading geniodb kernel modules..."
[ -f /lib/modules/geniodb.ko ] && insmod /lib/modules/geniodb.ko

# Do a blocking read until nmon is ready
cat /proc/boot/nmon_kick >/dev/null

[ -f /lib/modules/nmon_gpl.ko ] && insmod /lib/modules/nmon_gpl.ko
# Insmod gpon_i2c after nmon is ready, if any
[ -f /lib/modules/`uname -r`/extra/bcm3450.ko ] && insmod /lib/modules/`uname -r`/extra/bcm3450.ko
[ -f /lib/modules/`uname -r`/extra/gpon_i2c.ko ] && insmod /lib/modules/`uname -r`/extra/gpon_i2c.ko

# Load ploam driver
[ -f /lib/modules/`uname -r`/extra/bcmgpon.ko ]   && insmod /lib/modules/`uname -r`/extra/bcmgpon.ko
  
# Load voice drivers (vega and 6358)
[ -f /lib/modules/tty_spi.ko ]    && insmod /lib/modules/tty_spi.ko speed=1

# The /usr/bin/bootmode requires that /dev/nmon/genops is accessible from user space. 
# On the other hand endpoint driver depends on the voice part being initialised
# Therefore we must split the loop that assigns major numbers to NMON devices

[ -c /dev/rawstorage ] && [ -f /lib/modules/`uname -r`/extra/rawstorage.ko ] && insmod /lib/modules/`uname -r`/extra/rawstorage.ko

NMON_DEVICES="syslog adsl rip leds genops dbg ipsec nmontrace nmonerr rt_event efu"
for dev in $NMON_DEVICES
 do if [ ! -c /dev/nmon/$dev ]
     then
        major=`cat /proc/devices|grep $dev |cut -d' ' -f 1`

        if [ -z $major ]
        then
                echo "Device $dev not present."
        else
                mknod /dev/nmon/$dev c $major 0
        fi
     fi
  done

major=`cat /proc/devices|grep adsl |cut -d' ' -f 1`
if [ -z $major ]
then
    echo "Device adsl1 not present."
else
    mknod /dev/nmon/adsl1 c $major 1
fi

# In order to reduce the memory footprint during remote upgrade on platforms that need reduced memory
# the voice DSP image will not be allocated during reduced memory restart. Therefore we must skip loading
# modules that depend on the presemce of the DSP image (see CPE_P00063748)

# now we have /dev/nmon/genops, so we can use it to check that we are in reduced mode
do_load=1
bootmode=/usr/bin/bootmode
#
# Check if we need to boot into the 'reduced' mode:
#
if [ -x $bootmode ]; then
    $bootmode -s reduced
    if [ $? -eq 0 ]; then
        echo "Voice modules WILL NOT be loaded"
        do_load=0
    fi
fi

if [ ! $do_load -eq 0 ]; then
   echo  "voice will be loaded"
   [ -f /lib/modules/krtp.ko ]       && insmod /lib/modules/krtp.ko output_file=/proc/vdsp
   [ -f /lib/modules/dspdd.ko ]      && insmod /lib/modules/dspdd.ko
   [ -f /lib/modules/bt_reset.ko ]   && insmod /lib/modules/bt_reset.ko
   if [ ! -f /middleware/usr/bin/mmpbxd ]; then
       [ -f /lib/modules/endpointdd.ko ] && insmod /lib/modules/endpointdd.ko output_file=/proc/vdsp
       [ -f /lib/modules/dectshim.ko ]   && insmod /lib/modules/dectshim.ko 
   fi 
fi

[ -f /lib/modules/`uname -r`/extra/pwrmngtd.ko ]   && insmod /lib/modules/`uname -r`/extra/pwrmngtd.ko

# The l2cap module can be loaded with modprobe, as it is located in /lib/modules/`uname -r`
# It is only compiled in for onboard DECT support.
[ -f /lib/modules/`uname -r`/kernel/net/bluetooth/l2cap.ko ] && modprobe l2cap

if [ -f /middleware/usr/bin/mmpbxd ]; then
    NMON_DEVICES2="ikanos"
else
NMON_DEVICES2="endpoint ikanos soc4e"
fi
for dev in $NMON_DEVICES2
 do if [ ! -c /dev/nmon/$dev ] 
     then
	major=`cat /proc/devices|grep $dev |cut -d' ' -f 1`
	
	if [ -z $major ]
	then
		echo "Device $dev not present."
	else
        	mknod /dev/nmon/$dev c $major 0
	fi
     fi
  done

# create all buttons. Some of them will be linked to BSP buttons, some to external buttons,
# some to nothing (depending on the board)
BUTTON_DEVICE="button"
	major=`cat /proc/devices|grep $BUTTON_DEVICE |cut -d' ' -f 1`
	
	if [ -z $major ]
	then
		echo "Device $BUTTON_DEVICE not present."
	else
		mkdir /dev/nmon/$BUTTON_DEVICE
		mknod /dev/nmon/$BUTTON_DEVICE/restart		 c $major 1
		mknod /dev/nmon/$BUTTON_DEVICE/bootp		 c $major 2
		mknod /dev/nmon/$BUTTON_DEVICE/jtagsel		 c $major 3
		mknod /dev/nmon/$BUTTON_DEVICE/rtfd		 c $major 4
		mknod /dev/nmon/$BUTTON_DEVICE/wifi_pair	 c $major 5
		mknod /dev/nmon/$BUTTON_DEVICE/wifi_ext		 c $major 6
		mknod /dev/nmon/$BUTTON_DEVICE/dect_pair	 c $major 7
		mknod /dev/nmon/$BUTTON_DEVICE/dect_page	 c $major 8
		mknod /dev/nmon/$BUTTON_DEVICE/eco0		 c $major 9
		mknod /dev/nmon/$BUTTON_DEVICE/eco1		 c $major 10
		mknod /dev/nmon/$BUTTON_DEVICE/bluetooth0	 c $major 11
		mknod /dev/nmon/$BUTTON_DEVICE/bluetooth1	 c $major 12
		mknod /dev/nmon/$BUTTON_DEVICE/ext0		 c $major 13
		mknod /dev/nmon/$BUTTON_DEVICE/ext1		 c $major 14
		mknod /dev/nmon/$BUTTON_DEVICE/ext2		 c $major 15
		mknod /dev/nmon/$BUTTON_DEVICE/ext3		 c $major 16
		mknod /dev/nmon/$BUTTON_DEVICE/info		 c $major 17
	fi

[ -x /usr/bin/shcmdproxy ] && /usr/bin/shcmdproxy &
[ -x /etc/init.d/network ] && /etc/init.d/network start
# this should be handled by the storagepl (only 58-platforms)
#[ -x /etc/init.d/usb-host ] && /etc/init.d/usb-host start
[ -x /etc/init.d/vega ] && /etc/init.d/vega start

#[ -x /usr/bin/dropbear ] && /usr/bin/dropbear 
#[ -x /etc/init.d/telnetd ] && /etc/init.d/telnetd start

 echo "Syncing hardware clock to system time"
  [ -f /proc/driver/rtc ] && [ -x /sbin/hwclock ] && /sbin/hwclock -s

