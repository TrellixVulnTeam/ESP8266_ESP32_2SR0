<%
    require "lfs"

    cgilua.lp.include("lp/mbus_util.lp")
    cgilua.lp.include("lp/common.lp")
    cgilua.lp.include("lp/util.lp")
    cgilua.lp.include("lp/style.lp")
    cgilua.lp.include("lp/device.lp")
    cgilua.lp.include("lp/form.lp")
    cgilua.lp.include("lp/voip.lp")
    cgilua.contentheader ("text", "xml")
    local action = cgilua.POST["Action"]
    local clientID = string.sub(tostring(cgilua.POST["ClientID"]), 1, 32)
    local cliNumber = cgilua.POST["Cli"]
    local modify = {}

    local provisionPath = "SIPServer.Autoprovisioning"
    local uamap2Path = "Device.Services.VoiceService.2.X_TELECOMITALIA_IT_UAMapping"
    local uamap3Path = "Device.Services.VoiceService.3.X_TELECOMITALIA_IT_UAMapping"
    local actionState, intuaPath

    local function unlock()

      lfs.rmdir("/tmp/lockdir")
      
    end

    local function lock()

      local i = 0

      while true do
	if lfs.mkdir("/tmp/lockdir") == true then
	  break
	end
	
	sleep(1)
	
	i = i + 1
	
	if i == 120 then
	  trace("SIPGwConfig: Unable to capture the lock. Other script instance still in progress? Forcing unlock and continuing")
	  unlock()
	end
      end

    end

    --get the extua path for registrar and exam the input number by user is valid or not.
    function getExtPath(cli)
        for i=1, 4 do
	    local final
            local ePath = "Device.Services.VoiceService.2.VoiceProfile." .. i ..".Line.1.SIP"
            local replyExtua, errorExtua = mbus.getParameters{path=ePath, param="AuthUserName", datamodel="second"}
            local extuaMap = replyExtua[ePath][1].param["AuthUserName"]
            local extuaMapPath = "Device.Services.VoiceService.2.VoiceProfile." .. i ..".Line.1"
	    --Fix for CPE_P00118695
	    local extua_num = tostring(extuaMap)
	    local result = string.match(extua_num,"+39",1)
	    if result == "+39"
	    then
	    final = string.sub (extua_num,4)
	    else 
	    final = extua_num
	    end
            if tostring(cli) == final then
                return extuaMapPath
            end
        end
        return false
    end

    --judge if the extua had exist mapping relationship.
    function isMapExist(path)
        local uamapPath = "Device.Services.VoiceService.2.X_TELECOMITALIA_IT_UAMapping"
        local defaultIntua = "Device.Services.VoiceService.3.VoiceProfile.1.Line.1"
        local replyUamap, errorUamap = mbus.getParameters{path=uamapPath, param={"FromUA", "ToUA"}, datamodel="second"}
        for i,v in pairs(replyUamap[uamapPath]) do
            if v.param["FromUA"]==path and v.param["ToUA"]~=defaultIntua then
                return true
            end
        end
        return false
    end

    --judge if the uamap object is exist or not.
    function existOfUamap(intPath, extPath)
        local isExist = false
        local uamapPath = "Device.Services.VoiceService.2.X_TELECOMITALIA_IT_UAMapping"
        local reply, error = mbus.getParameters{path=uamapPath, param={"FromUA", "ToUA"}, datamodel="second"}
        if reply~=nil and reply[uamapPath][1]~=nil and reply[uamapPath][1].param["FromUA"]~=nil and reply[uamapPath][1].param["ToUA"]~=nil then
            local fromUa = reply[uamapPath][1].param["FromUA"]
            local toUa = reply[uamapPath][1].param["ToUA"]
            if tostring(fromUa)==tostring(extPath) and tostring(toUa)==tostring(intPath) then
                isExist = true
            end
        end
        return isExist
    end

    --judge if the vpmap object is exist or not.
    function existOfVpmap(intPath, extPath)
        local isExist = false
        local vpmapPath = "Device.Services.VoiceService.3.X_TELECOMITALIA_IT_UAMapping"
        local reply, error = mbus.getParameters{path=vpmapPath, param={"FromUA", "ToUA"}, datamodel="second"}
        if reply~=nil and reply[vpmapPath][1]~=nil and reply[vpmapPath][1].param["FromUA"]~=nil and reply[vpmapPath][1].param["ToUA"]~=nil then
            local fromUa = reply[vpmapPath][1].param["FromUA"]
            local toUa = reply[vpmapPath][1].param["ToUA"]
            if tostring(fromUa)==tostring(intPath) and tostring(toUa)==tostring(extPath) then
                isExist = true
            end
        end
        return isExist
    end

    --delete the exist mapping relationship on the same intua.
    function delExistIntuaMapping(intPath)
        local reply, error = mbus.getParameters{path=uamap2Path, datamodel="second"}
        if reply[uamap2Path][1]~=nil then
            local replyDel, errorDel = mbus.modify(
            function()
                local replyDelete, errorDelete = mbus.deleteObjects{path = uamap2Path, filter="(== ToUA " .. intPath .. ")", datamodel = "second"}
            end, {datamodel="second"})
        end
        local reply, error = mbus.getParameters{path=uamap3Path, datamodel="second"}
        if reply[uamap3Path][1]~=nil then
            local replyDel, errorDel = mbus.modify(
            function()
                local replyDelete, errorDelete = mbus.deleteObjects{path = uamap3Path, filter="(== FromUA " .. intPath .. ")", datamodel = "second"}
            end, {datamodel="second"})
        end
        return
    end
        
    if action~="" then
	--judge the ISP is Telecom Italia or not.
	local ISPPath = "Device.UserInterface"
	local replyISP, errorISP = mbus.getParameters{path=ISPPath, param="ISPName", datamodel="second"}
	if replyISP[ISPPath][1]~=nil and replyISP[ISPPath][1].param~=nil then
	    local ISPName = replyISP[ISPPath][1].param["ISPName"]
	    if ISPName~="Telecom Italia" then
		httperror(553, "ISP is not correct")
		return
	    end
	else
	    httperror(553, "ISP is not correct")
	    return
	end
	
	
	-- try to get a lock
	lock()
  	
	--Exam the number which user used to autoprovisioning is can be used or not.
	local teleNumExist = getExtPath(cliNumber)
	if teleNumExist ~= false then
	    local extuaMapPath = getExtPath(cliNumber)
	    local isUamapExist = isMapExist(extuaMapPath)
	    if isUamapExist == false then
		--there is no uamap, so add the map relationship between intua and extua.
		for i=2, 11 do
		    local intuaMapPath = "Device.Services.VoiceService.3.VoiceProfile." .. i .. ".Line.1"
		    local extPath, intPath
		    local replyIntua, errorIntua = mbus.getParameters{path=intuaMapPath, param="X_TELECOMITALIA_IT_PhyAssignment", datamodel="second"}
		    local intuaNotAssign = replyIntua[intuaMapPath][1].param["X_TELECOMITALIA_IT_PhyAssignment"]
		    local replyIntua1, errorIntua1 = mbus.getParameters{path=intuaMapPath, param="X_TELECOMITALIA_IT_MACAddress", datamodel="second"}
            local intuaNotAssign1 = replyIntua1[intuaMapPath][1].param["X_TELECOMITALIA_IT_MACAddress"]
		    if intuaNotAssign == "Not Assigned" or intuaNotAssign1 == clientID then
			intPath = replyIntua[intuaMapPath][1].path
			extPath = getExtPath(cliNumber)

			--when add a new intua mapping, just delete the old mapping in this intua if exist.
			delExistIntuaMapping(intuaMapPath)

			local reply, error = mbus.modify(
			function()
			    local reply1, error1 = mbus.addObjects{path=uamap2Path, param={FromUA=extPath, ToUA=intPath}, datamodel = "second" }
			    if error1~=nil or reply1[uamap2Path][1]==nil then
				result=1
				cgilua.errorlog("error1 is not nil:")
			    end
			end, {datamodel="second"})

			local reply2, error2 = mbus.modify(
			function()
			    local reply3, error3 = mbus.addObjects{path=uamap3Path, param={FromUA=intPath, ToUA=extPath}, datamodel = "second" }
			    if error3~=nil or reply3[uamap3Path][1]==nil then
				result=1
				cgilua.errorlog("error3 is not nil:")
			    end
			end, {datamodel="second"})
			saveall(0, 1)
			break
		    end
		end
	    else --if exist, that means already some phones had been registered, new phone need to autoprovisioning
		local replyTotal, errorTotal = mbus.getParameters{path=uamap2Path, param="ToUA", filter="(== FromUA " .. extuaMapPath .. ")", datamodel="second"}
		--no matter if there is mapping between intua and extua, just select the first valid intua mapped to the extua.
		local totalnum = #replyTotal[uamap2Path]
		--if 9 object had existed, means from intua2 to intua10 all of them had been registered, no valid intua for the phone to autoprovisioning.
		if tostring(totalnum) ~= "10" then
		    for i=2, 11 do
			local intuaMapPath = "Device.Services.VoiceService.3.VoiceProfile." .. i .. ".Line.1"
			local extPath, intPath
			local replyIntua, errorIntua = mbus.getParameters{path=intuaMapPath, param="X_TELECOMITALIA_IT_PhyAssignment", datamodel="second"}
			local intuaNotAssign = replyIntua[intuaMapPath][1].param["X_TELECOMITALIA_IT_PhyAssignment"]
			local replyIntua1, errorIntua1 = mbus.getParameters{path=intuaMapPath, param="X_TELECOMITALIA_IT_MACAddress", datamodel="second"}
            local intuaNotAssign1 = replyIntua1[intuaMapPath][1].param["X_TELECOMITALIA_IT_MACAddress"]
			if intuaNotAssign == "Not Assigned" or intuaNotAssign1 == clientID then
			    intPath = replyIntua[intuaMapPath][1].path
			    extPath = getExtPath(cliNumber)

			    --when add a new intua mapping, just delete the old mapping in this intua if exist.
			    delExistIntuaMapping(intuaMapPath)

			    local isUamapExist = existOfUamap(intPath, extPath)
			    if isUamapExist==false then
				local reply, error = mbus.modify(
				function()
				    local reply1, error1 = mbus.addObjects{path=uamap2Path, param={FromUA=extPath, ToUA=intPath}, datamodel = "second" }
				    if error1~=nil or reply1[uamap2Path][1]==nil then
					result=1
					cgilua.errorlog("error1 is not nil:")
				    end
				end, {datamodel="second"})
			    end

			    local isVpmapExist = existOfVpmap(intPath, extPath)
			    if isVpmapExist==false then
				local reply2, error2 = mbus.modify(
				function()
				    local reply3, error3 = mbus.addObjects{path=uamap3Path, param={FromUA=intPath, ToUA=extPath}, datamodel = "second" }
				    if error3~=nil or reply3[uamap3Path][1]==nil then
					result=1
					cgilua.errorlog("error3 is not nil:")
				    end
				end, {datamodel="second"})
			    end
			    saveall(0, 1)
			    break
			end
		    end

		else  --fix bug of CPE_P00111316:Autoprovisioned IP phone overwrittes another IP Phone.
		    for i=2, 11 do
			local intuaMapPath = "Device.Services.VoiceService.3.VoiceProfile." .. i .. ".Line.1"
			local extPath, intPath
			local replyIntua, errorIntua = mbus.getParameters{path=intuaMapPath, param="X_TELECOMITALIA_IT_PhyAssignment", datamodel="second"}
			local intuaNotAssign = replyIntua[intuaMapPath][1].param["X_TELECOMITALIA_IT_PhyAssignment"]
			local replyIntua1, errorIntua1 = mbus.getParameters{path=intuaMapPath, param="X_TELECOMITALIA_IT_MACAddress", datamodel="second"}
            local intuaNotAssign1 = replyIntua1[intuaMapPath][1].param["X_TELECOMITALIA_IT_MACAddress"]
			if intuaNotAssign == "Not Assigned" or intuaNotAssign1 == clientID then
			    intPath = replyIntua[intuaMapPath][1].path
			    extPath = getExtPath(cliNumber)

			    --when add a new intua mapping, just delete the old mapping in this intua if exist.
			    delExistIntuaMapping(intuaMapPath)

			    local reply, error = mbus.modify(
			    function()
				local reply1, error1 = mbus.addObjects{path=uamap2Path, param={FromUA=extPath, ToUA=intPath}, datamodel = "second" }
				if error1~=nil or reply1[uamap2Path][1]==nil then
				    result=1
				    cgilua.errorlog("error1 is not nil:")
				end     
			    end, {datamodel="second"})

			    local reply2, error2 = mbus.modify(
			    function()
				local reply3, error3 = mbus.addObjects{path=uamap3Path, param={FromUA=intPath, ToUA=extPath}, datamodel = "second" }
				if error3~=nil or reply3[uamap3Path][1]==nil then
				    result=1
				    cgilua.errorlog("error3 is not nil:")
				end
			    end, {datamodel="second"})
			    saveall(0, 1)
			    break
			end
		    end
		end
	    end
	end

	--judge the device's WIFI method is WPA or WPA2 in the WLAN.
	local ipOfDevice = cgilua.servervariable"REMOTE_ADDR"
	local replyHost, errorHost = mbus.getParameters{path="Hosts.Host", param="Interface", filter="(== IPAddress "..ipOfDevice..")"}
	if replyHost["Hosts.Host"][1]~=nil and replyHost["Hosts.Host"][1].param~=nil then
	    local ethPath = replyHost["Hosts.Host"][1].param["Interface"]
	    local replyEth, errorEth = mbus.getParameters{path=ethPath, param={"Technology", "Reference"}}
	    if replyEth[ethPath][1]~=nil and replyEth[ethPath][1].param~=nil then
		local ethTech = replyEth[ethPath][1].param["Technology"]
		if ethTech=="WLAN" then
		    local referenceWlan = replyEth[ethPath][1].param["Reference"]
		    local wlanPath = tostring(referenceWlan) .. ".Security"
		    local replyWlan, errorWlan = mbus.getParameters{path=wlanPath, param="Mode"}
		    if replyWlan[wlanPath][1]~=nil and replyWlan[wlanPath][1].param~=nil then
			local wifiMode = replyWlan[wlanPath][1].param["Mode"]
			if wifiMode=="disabled" or wifiMode=="WEP" then
			    httperror(550, "Insecure connection")
			    unlock()
			    return
			end
		    end
		end
	    end
	end

	if action=="GetConfig" then
	    local cliNumber = cgilua.POST["Cli"]
	    local reply, error = mbus.modify(
		function()
		    local reply1, error1 = mbus.setParameters{path=provisionPath, param={ActionType=action, MAC=clientID, CLI=cliNumber}}
		end)
	    local reply2, error2 = mbus.modify(
		function()
		    local reply3, error3 = mbus.setParameters{path=provisionPath, param={ActionState="Requested"}}
		end)
	    saveall(0, 1)
	elseif action=="DisableConfig" then
	    local reply, error = mbus.modify(
		function()
		    local reply1, error1 = mbus.setParameters{path=provisionPath, param={ActionType=action}}
		end)
	    local reply2, error2 = mbus.modify(
		function()
		    local reply3, error3 = mbus.setParameters{path=provisionPath, param={ActionState="Requested"}}
		end)
	    saveall(0, 1)
	end
	local reply4, error4 = mbus.getParameters{path=provisionPath, param={"ActionState", "InternalUAReference"}}
	actionState = reply4[provisionPath][1].param["ActionState"]
	intuaPath = reply4[provisionPath][1].param["InternalUAReference"]
	--Get the value of xml parameters when the param of "ActionState" is "Completed"
	if actionState=="Completed" then
	    local reply5, error5 = mbus.getParameters{path=provisionPath, param="ActionStatus"}
	    local resStatus = reply5[provisionPath][1].param["ActionStatus"]
	    --error code exam.
	    if resStatus == "CLI is not correct" then
		httperror(551, "CLI is not correct")
		unlock()
		return
	    end
	    if resStatus == "Unable to find ClientID" then
		httperror(552, "Unable to find ClientID")
		unlock()
		return
	    end
	    if resStatus == "No available accounts" then
		httperror(554, "No available accounts")
		unlock()
		return
	    end
	    if resStatus == "OK" then
		--action successful.
		if action == "GetConfig" then
		    local xmlStart="\<?xml version=\"1.0\" encoding=\"UTF-8\"?\>"
		    local xmlStr, transportProtocol = "", "UDP"
		    local name, password, realm, realmPath, registrar, registrarPort, outboundProxy, proxyPort, regPath = "", "", "", "", "", "", "", "", ""
		    local uaPath = "SIPServer.InternalUA"
		    local registrarPath = "SIPServer.Registrar.Bind"

		    local reply, error = mbus.getParameters{path=uaPath, param={"Username", "Password", "Realm" , "UserAgentDomain" , "UserAgentPort"}}
		    for i,v in pairs(reply[uaPath]) do
			if v.path==tostring(intuaPath) then
			    name = v.param["Username"]
			    password = v.param["Password"]
			    realmPath = v.param["Realm"]
							registrar = v.param["UserAgentDomain"]
							outboundProxy = registrar
							registrarPort = v.param["UserAgentPort"]
							
			    local replyRealm, error = mbus.getParameters{path=realmPath, param="realm"}
			    if replyRealm[realmPath][1]~=nil and replyRealm[realmPath][1].param~=nil then
				realm = replyRealm[realmPath][1].param["realm"]
			    end

			    --local replyRegistrar, errorRegistrar = mbus.getParameters{path=registrarPath, param={"IPIntf", "SIPPort"}}
			    --regPath = replyRegistrar[registrarPath][1].param["IPIntf"]
			    --registrarPort = replyRegistrar[registrarPath][1].param["SIPPort"]

			    --local intfPath = tostring(regPath) .. ".Addr.1"
			    --local replyIntfPath, errorIntfPath = mbus.getParameters{path=intfPath, param="IPAddress"}
			    --registrar = replyIntfPath[intfPath][1].param["IPAddress"]
			    --outboundProxy = registrar
			    proxyPort = registrarPort
			end
		    end

		    xmlStr = xmlStr .. "\<AuthUserName\>"..name.."\</AuthUserName\>".."\<AuthPassword\>"..password.."\</AuthPassword\>".."\<AuthRealm\>"..realm.."\</AuthRealm\>".."\<Registrar\>"..registrar.."\</Registrar\>".."\<RegistrarPort\>"..registrarPort.."\</RegistrarPort\>".."\<OutboundProxy\>"..outboundProxy.."\</OutboundProxy\>".."\<OutboundProxyPort\>"..proxyPort.."\</OutboundProxyPort\>".."\<TransportProtocol\>"..transportProtocol.."\</TransportProtocol\>"
		    xmlStr = "\<SIPClientConfig\>" .. xmlStr .. "\<\/SIPClientConfig\>"
		    cgilua.print(xmlStart ..  tostring(xmlStr))
		    unlock()
		    return
		elseif action == "DisableConfig" then
		    local proPath = "Device.Services.VoiceService.3.VoiceProfile"
		    local reply, error = mbus.getParameters{path = proPath, datamodel = "second"}
		    for i,v in pairs(reply[proPath]) do
			local macPath = v.path .. ".Line.1"
			local reply1, error1 = mbus.getParameters{path = macPath, param = {"Enable", "X_TELECOMITALIA_IT_MACAddress"}, filter = "(== X_TELECOMITALIA_IT_MACAddress " .. clientID .. ")", datamodel = "second"}
			if reply1[macPath]~=nil and reply1[macPath][1]~=nil then
			    local reply, error = mbus.modify(
				    function()    
					    local reply2, error2 = mbus.setParameters{path = macPath, param = {Enable="Disabled"}, datamodel = "second"}
				    end, {datamodel="second"})
			    saveall(0, 1)
			end
		    end
		    unlock()
		    return
		end
	    end
	end
	
	unlock()
    end
%>
